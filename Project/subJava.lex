open AST

(* Stuff done to make use of the Tokens module generated by subJava.grm *)

type pos 			= int
type svalue			= Tokens.svalue
type ('a,'b) token	= ('a,'b) Tokens.token
type lexresult		= (svalue,pos) token

open Tokens
val lineRef = ref 1
fun updateLine n = lineRef := (!lineRef) + n
fun resetLine () = lineRef := 1
val charRef = ref 0
fun updateChar n = charRef := (!charRef) + n
fun resetChar () = charRef := 0

fun initLexer () = (resetLine(); resetChar())
fun posn ()	= (!lineRef, !charRef)

fun error (e,l : int, r : int) = TextIO.output(TextIO.stdErr, "line" ^ Int.toString l ^ "." ^ Int.toString r ^ ":" ^ e ^ "\n")

fun eof   ()      = Tokens.EOF (!lineRef,!charRef)

%%
%header (functor subJavaLexFun(structure Tokens : subJava_TOKENS));
ws    = [\ \t];
%%

\n									=> (updateLine 1; resetChar(); lex() );
{ws}+                              	=> (updateChar (String.size yytext); lex() );

"="									=> (updateChar 1; ASSIGN(!lineRef , !charRef));
"+"									=> (updateChar 1; PLUS(!lineRef, !charRef));
"-"									=> (updateChar 1; MINUS(!lineRef, !charRef));
"*"									=> (updateChar 1; MUL(!lineRef, !charRef));
"/"									=> (updateChar 1; DIV(!lineRef, !charRef));
"&&"								=> (updateChar 2; AND(!lineRef, !charRef));
"||"								=> (updateChar 2; OR(!lineRef, !charRef));
"!"									=> (updateChar 1; NOT(!lineRef, !charRef));
"=="								=> (updateChar 2; EQUAL(!lineRef, !charRef));
"!="								=> (updateChar 2; NOTEQUAL(!lineRef, !charRef));
"<"									=> (updateChar 1; LESS(!lineRef, !charRef));
"<="								=> (updateChar 2; LESSEQUAL(!lineRef, !charRef));
">"									=> (updateChar 1; GREATER(!lineRef, !charRef));
">="								=> (updateChar 2; GREATEREQUAL(!lineRef, !charRef));

";"									=> (updateChar 1; SEMICOLON(!lineRef, !charRef));
","									=> (updateChar 1; COMMA(!lineRef, !charRef));
"."									=> (updateChar 1; DOT(!lineRef, !charRef));
"("									=> (updateChar 1; LPARA(!lineRef, !charRef));
")"									=> (updateChar 1; RPARA(!lineRef, !charRef));
"{"                                 => (updateChar 1; LBRACE(!lineRef, !charRef));
"}"                                 => (updateChar 1; RBRACE(!lineRef, !charRef));
"["                                 => (updateChar 1; LBRACKET(!lineRef, !charRef));
"]"                                 => (updateChar 1; RBRACKET(!lineRef, !charRef));

"boolean"							=> (updateChar 7; BOOL(!lineRef, !charRef));
"class"								=> (updateChar 5; CLASS(!lineRef, !charRef));
"else"								=> (updateChar 4; ELSE(!lineRef, !charRef));
"false"								=> (updateChar 5; FALSE(!lineRef, !charRef));
"if"								=> (updateChar 2; IF(!lineRef, !charRef));
"int"								=> (updateChar 3; INT(!lineRef, !charRef));
"length"							=> (updateChar 6; LENGTH(!lineRef, !charRef));
"main"								=> (updateChar 4; MAIN(!lineRef, !charRef));
"new"								=> (updateChar 3; NEW(!lineRef, !charRef));
"public"							=> (updateChar 6; PUBLIC(!lineRef, !charRef));
"return"							=> (updateChar 6; RETURN(!lineRef, !charRef));
"static"							=> (updateChar 6; STATIC(!lineRef, !charRef));
"String"							=> (updateChar 6; STRING(!lineRef, !charRef));
"System.out.println"				=> (updateChar 18; PRINT(!lineRef, !charRef));
"this"								=> (updateChar 4; THIS(!lineRef, !charRef));
"true"								=> (updateChar 4; TRUE(!lineRef, !charRef));
"void"								=> (updateChar 4; VOID(!lineRef, !charRef));
"while"								=> (updateChar 5; WHILE(!lineRef, !charRef));

"//".*\n							=> (updateLine 1; resetChar(); lex());

[0-9]+								=> (updateChar (String.size yytext); NUMBER(valOf (Int.fromString yytext), !lineRef, !charRef));
[_a-zA-Z][_0-9a-zA-Z]*				=> (updateChar (String.size yytext); ID(yytext, !lineRef, !charRef));
"\""[\032\033\035-\126]"*\""		=> (updateChar (String.size yytext); STRINGLITERAL(String.substring(yytext, 1, (String.size yytext) -1), !lineRef, !charRef));

.									=> (error("Bad Character: [" ^ yytext ^ "]\n", !lineRef, !charRef); lex());